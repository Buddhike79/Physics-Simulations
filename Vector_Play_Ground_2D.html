<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Vector Calculator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        canvas {
            cursor: crosshair;
            touch-action: none; /* Disables browser gestures like panning */
        }

        /* NOTE: @apply only works with a Tailwind build step; if you use the CDN, prefer inline utility classes.
           Keeping these here since they were in your original, but they won't have an effect without processing. */
        .tab-button {
            /* @apply py-2 px-4 font-medium text-sm rounded-lg; */
        }
        .tab-active {
            /* @apply bg-indigo-600 text-white shadow; */
        }
        .tab-inactive {
            /* @apply bg-gray-200 text-gray-700 hover:bg-gray-300; */
        }

        /* --- Bottom-right credit (always visible) --- */
        .app-credit {
            position: fixed;
            right: 16px;
            bottom: 8px;
            font-size: 12px;
            font-style: italic;
            color: #6B7280; /* Tailwind gray-500 */
            pointer-events: none; /* don’t block clicks */
            z-index: 50;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-4xl bg-white p-6 rounded-2xl shadow-xl">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-4">2D Vector Calculator</h1>

        <!-- Tab Navigation -->
        <div class="flex justify-center space-x-2 mb-4 p-1 bg-gray-100 rounded-lg">
            <button id="tab-ops" class="py-2 px-4 font-medium text-sm rounded-lg bg-indigo-600 text-white shadow w-1/2">Vector Operations</button>
            <button id="tab-res" class="py-2 px-4 font-medium text-sm rounded-lg bg-gray-200 text-gray-700 hover:bg-gray-300 w-1/2">Vector Resolution</button>
        </div>

        <div class="flex flex-col md:flex-row gap-6">

            <!-- Left Panel: Controls -->
            <div class="w-full md:w-1/3 space-y-4">
                
                <!-- Vector Operations Controls (Visible by default) -->
                <div id="controls-ops">
                    <p class="text-sm text-gray-600 mb-4">Click & drag vector tips (A, B, or R) or enter values below. The graph updates dynamically.</p>
                    
                    <!-- Vector A -->
                    <div class="p-3 rounded-lg border border-blue-200 bg-blue-50">
                        <h3 class="font-bold text-lg text-blue-700">Vector A</h3>
                        <div class="grid grid-cols-2 gap-2 mt-2">
                            <div>
                                <label for="magA" class="text-xs font-medium text-blue-600">Magnitude</label>
                                <input type="number" id="magA" value="80" class="w-full p-1.5 border border-blue-300 rounded-md text-sm">
                            </div>
                            <div>
                                <label for="angleA" class="text-xs font-medium text-blue-600">Angle (°)</label>
                                <input type="number" id="angleA" value="30" class="w-full p-1.5 border border-blue-300 rounded-md text-sm">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Vector B -->
                    <div class="p-3 rounded-lg border border-pink-200 bg-pink-50">
                        <h3 class="font-bold text-lg text-pink-700">Vector B</h3>
                        <div class="grid grid-cols-2 gap-2 mt-2">
                            <div>
                                <label for="magB" class="text-xs font-medium text-pink-600">Magnitude</label>
                                <input type="number" id="magB" value="60" class="w-full p-1.5 border border-pink-300 rounded-md text-sm">
                            </div>
                            <div>
                                <label for="angleB" class="text-xs font-medium text-pink-600">Angle (°)</label>
                                <input type="number" id="angleB" value="120" class="w-full p-1.5 border border-pink-300 rounded-md text-sm">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Graph Scale -->
                    <div class="p-3 rounded-lg border border-gray-200 bg-gray-50">
                        <h3 class="font-bold text-lg text-gray-700">Settings</h3>
                        <div>
                            <label for="scale" class="text-xs font-medium text-gray-600">Graph Scale</label>
                            <input type="number" id="scale" value="1.5" step="0.1" class="w-full p-1.5 border border-gray-300 rounded-md text-sm">
                        </div>
                    </div>

                    <!-- Operation Buttons -->
                    <div class="grid grid-cols-1 gap-2 pt-2">
                        <button id="add" class="w-full bg-indigo-600 text-white font-semibold py-2 px-4 rounded-lg shadow hover:bg-indigo-700 transition-colors">Add (A + B)</button>
                        <button id="subtract" class="w-full bg-indigo-600 text-white font-semibold py-2 px-4 rounded-lg shadow hover:bg-indigo-700 transition-colors">Sub (A - B)</button>
                        <button id="subtractBA" class="w-full bg-indigo-600 text-white font-semibold py-2 px-4 rounded-lg shadow hover:bg-indigo-700 transition-colors">Sub (B - A)</button>
                    </div>
                    
                    <!-- Result Display -->
                    <div id="result-ops" class="mt-4 p-3 rounded-lg border border-purple-200 bg-purple-50 hidden">
                        <h3 class="font-bold text-lg text-purple-700">Result (R)</h3>
                        <p class="text-sm text-purple-600">Mag: <strong id="magR" class="font-bold">0.0</strong> | Angle: <strong id="angleR" class="font-bold">0.0</strong>°</p>
                    </div>
                </div>
                
                <!-- Vector Resolution Controls (Hidden by default) -->
                <div id="controls-res" class="hidden">
                    <p class="text-sm text-gray-600 mb-4">Define a vector 'V' and an axis to resolve it against. You can drag V, V∥, or V⊥.</p>
                    
                    <!-- Vector V -->
                    <div class="p-3 rounded-lg border border-green-200 bg-green-50">
                        <h3 class="font-bold text-lg text-green-700">Vector V</h3>
                        <div class="grid grid-cols-2 gap-2 mt-2">
                            <div>
                                <label for="magV" class="text-xs font-medium text-green-600">Magnitude</label>
                                <input type="number" id="magV" value="100" class="w-full p-1.5 border border-green-300 rounded-md text-sm">
                            </div>
                            <div>
                                <label for="angleV" class="text-xs font-medium text-green-600">Angle (°)</label>
                                <input type="number" id="angleV" value="45" class="w-full p-1.5 border border-green-300 rounded-md text-sm">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Resolving Axis -->
                    <div class="p-3 rounded-lg border border-gray-200 bg-gray-50">
                        <h3 class="font-bold text-lg text-gray-700">Resolving Axis</h3>
                        <div>
                            <label for="slopeAngle" class="text-xs font-medium text-gray-600">Slope Angle (°)</label>
                            <!-- This is the change you requested -->
                            <input type="number" id="slopeAngle" value="0" class="w-full p-1.5 border border-gray-300 rounded-md text-sm">
                        </div>
                    </div>

                    <!-- Result Display -->
                    <div id="result-res" class="mt-4 p-3 rounded-lg border border-gray-200 bg-gray-50">
                        <h3 class="font-bold text-lg text-gray-700">Components</h3>
                        <p class="text-sm text-gray-600">Parallel (V<sub>∥</sub>): <strong id="magParallel" class="font-bold">0.0</strong></p>
                        <p class="text-sm text-gray-600">Perpendicular (V<sub>⊥</sub>): <strong id="magPerp" class="font-bold">0.0</strong></p>
                    </div>
                </div>
            </div>

            <!-- Right Panel: Canvas -->
            <div class="w-full md:w-2/3">
                <canvas id="vectorCanvas" class="w-full h-96 md:h-full border border-gray-300 rounded-lg bg-white"></canvas>
            </div>
        </div>
    </div>

    <!-- Bottom-right credit -->
    <p class="app-credit">Created by Buddhike Priyadarshana</p>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('vectorCanvas');
            const ctx = canvas.getContext('2d');

            // --- Get DOM Elements ---
            // Tabs
            const tabOps = document.getElementById('tab-ops');
            const tabRes = document.getElementById('tab-res');
            const controlsOps = document.getElementById('controls-ops');
            const controlsRes = document.getElementById('controls-res');
            
            // Operations Tab
            const magAInput = document.getElementById('magA');
            const angleAInput = document.getElementById('angleA');
            const magBInput = document.getElementById('magB');
            const angleBInput = document.getElementById('angleB');
            const scaleInput = document.getElementById('scale');
            const addButton = document.getElementById('add');
            const subtractButton = document.getElementById('subtract');
            const subtractBAButton = document.getElementById('subtractBA');
            const resultOpsDiv = document.getElementById('result-ops');
            const magROutput = document.getElementById('magR');
            const angleROutput = document.getElementById('angleR');

            // Resolution Tab
            const magVInput = document.getElementById('magV');
            const angleVInput = document.getElementById('angleV');
            const slopeAngleInput = document.getElementById('slopeAngle');
            const resultResDiv = document.getElementById('result-res');
            const magParallelOutput = document.getElementById('magParallel');
            const magPerpOutput = document.getElementById('magPerp');

            // --- State Variables ---
            let appMode = 'ops'; // 'ops' or 'res'
            let opMode = null; // null, 'add', 'sub', 'subBA'
            let origin = { x: 0, y: 0 };
            let scale = parseFloat(scaleInput.value) || 1.5;
            let dpr = window.devicePixelRatio || 1;
            let width, height;

            // Vector objects
            let vecA = { mag: 0, angle: 0, x: 0, y: 0, color: '#2563EB' }; // Blue
            let vecB = { mag: 0, angle: 0, x: 0, y: 0, color: '#D946EF' }; // Pink
            let vecR = { mag: 0, angle: 0, x: 0, y: 0, color: '#10B981' }; // Green
            let vecV = { mag: 0, angle: 0, x: 0, y: 0, color: '#10B981' }; // Green
            let vecParallel = { mag: 0, angle: 0, x: 0, y: 0, color: '#F59E0B' }; // Amber
            let vecPerp = { mag: 0, angle: 0, x: 0, y: 0, color: '#8B5CF6' }; // Violet
            let slopeAngle = 0;

            let dragging = null; // null, 'A', 'B', 'R', 'V', 'V_PARALLEL', 'V_PERP'

            // --- Utility Functions ---
            const degToRad = (deg) => deg * (Math.PI / 180);
            const radToDeg = (rad) => rad * (180 / Math.PI);

            // Update vector from Magnitude/Angle
            function updateVectorFromPolar(vec, mag, angleDeg) {
                vec.mag = mag;
                vec.angle = angleDeg;
                const angleRad = degToRad(angleDeg);
                vec.x = mag * Math.cos(angleRad);
                vec.y = mag * Math.sin(angleRad);
            }

            // Update vector from X/Y
            function updateVectorFromCartesian(vec, x, y) {
                vec.x = x;
                vec.y = y;
                vec.mag = Math.sqrt(x * x + y * y);
                let angleRad = Math.atan2(y, x);
                vec.angle = radToDeg(angleRad);
            }

            // --- Canvas & Drawing ---
            function resizeCanvas() {
                const rect = canvas.getBoundingClientRect();
                width = rect.width;
                height = rect.height;
                canvas.width = width * dpr;
                canvas.height = height * dpr;
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                origin.x = width / 2;
                origin.y = height / 2;
                draw();
            }

            // Draw grid and axes
            function drawGrid() {
                ctx.save();
                ctx.strokeStyle = '#E5E7EB'; // Light gray
                ctx.lineWidth = 0.5;
                const gridSize = 20 * scale;

                // Vertical lines
                for (let x = origin.x % gridSize; x < width; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                    ctx.stroke();
                }
                // Horizontal lines
                for (let y = origin.y % gridSize; y < height; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }

                // Main Axes
                ctx.strokeStyle = '#9CA3AF'; // Medium gray
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, origin.y);
                ctx.lineTo(width, origin.y); // X-axis
                ctx.moveTo(origin.x, 0);
                ctx.lineTo(origin.x, height); // Y-axis
                ctx.stroke();
                
                ctx.restore();
            }

            // Draw a single vector
            function drawVector(x, y, color, label, lineDash = []) {
                ctx.save();
                ctx.strokeStyle = color;
                ctx.fillStyle = color;
                ctx.lineWidth = 3;
                ctx.setLineDash(lineDash);

                const startX = origin.x;
                const startY = origin.y;
                const endX = origin.x + x * scale;
                const endY = origin.y - y * scale; // Invert Y for canvas coords

                // Draw line
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();

                // Draw arrowhead
                const angle = Math.atan2(endY - startY, endX - startX);
                const headLength = 10;
                ctx.beginPath();
                ctx.moveTo(endX, endY);
                ctx.lineTo(endX - headLength * Math.cos(angle - Math.PI / 6), endY - headLength * Math.sin(angle - Math.PI / 6));
                ctx.lineTo(endX - headLength * Math.cos(angle + Math.PI / 6), endY - headLength * Math.sin(angle + Math.PI / 6));
                ctx.closePath();
                ctx.fill();

                // Draw label
                if (label) {
                    ctx.fillStyle = color;
                    ctx.font = 'bold 14px Inter';
                    ctx.fillText(label, endX + 10, endY + 5);
                }
                ctx.restore();
            }

            // Draw a vector from a custom start point
            function drawVectorFrom(startX, startY, endX, endY, color, lineDash = []) {
                ctx.save();
                ctx.strokeStyle = color;
                ctx.fillStyle = color;
                ctx.lineWidth = 2;
                ctx.setLineDash(lineDash);

                const sx = origin.x + startX * scale;
                const sy = origin.y - startY * scale;
                const ex = origin.x + endX * scale;
                const ey = origin.y - endY * scale;

                // Draw line
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                ctx.lineTo(ex, ey);
                ctx.stroke();
                
                // Draw arrowhead
                const angle = Math.atan2(ey - sy, ex - sx);
                const headLength = 8;
                ctx.beginPath();
                ctx.moveTo(ex, ey);
                ctx.lineTo(ex - headLength * Math.cos(angle - Math.PI / 6), ey - headLength * Math.sin(angle - Math.PI / 6));
                ctx.lineTo(ex - headLength * Math.cos(angle + Math.PI / 6), ey - headLength * Math.sin(angle + Math.PI / 6));
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            }

            // --- Core Logic ---
            function updateOpsInputs() {
                magAInput.value = vecA.mag.toFixed(1);
                angleAInput.value = vecA.angle.toFixed(1);
                magBInput.value = vecB.mag.toFixed(1);
                angleBInput.value = vecB.angle.toFixed(1);
            }
            
            function updateResInputs() {
                magVInput.value = vecV.mag.toFixed(1);
                angleVInput.value = vecV.angle.toFixed(1);
            }

            function calculateResultant() {
                if (opMode === 'add') {
                    updateVectorFromCartesian(vecR, vecA.x + vecB.x, vecA.y + vecB.y);
                } else if (opMode === 'sub') {
                    updateVectorFromCartesian(vecR, vecA.x - vecB.x, vecA.y - vecB.y);
                } else if (opMode === 'subBA') {
                    updateVectorFromCartesian(vecR, vecB.x - vecA.x, vecB.y - vecA.y);
                }
                
                if (opMode) {
                    resultOpsDiv.classList.remove('hidden');
                    magROutput.textContent = vecR.mag.toFixed(1);
                    angleROutput.textContent = vecR.angle.toFixed(1);
                } else {
                    resultOpsDiv.classList.add('hidden');
                }
            }
            
            function calculateResolution() {
                const vAngleRad = degToRad(vecV.angle);
                const slopeAngleRad = degToRad(slopeAngle);
                
                const angleDiff = vAngleRad - slopeAngleRad;
                
                const parallelMag = vecV.mag * Math.cos(angleDiff);
                const perpMag = vecV.mag * Math.sin(angleDiff);
                
                updateVectorFromPolar(vecParallel, parallelMag, slopeAngle);
                updateVectorFromPolar(vecPerp, perpMag, slopeAngle + 90);
                
                magParallelOutput.textContent = parallelMag.toFixed(1);
                magPerpOutput.textContent = perpMag.toFixed(1);
            }

            // --- Main Draw Loop ---
            function draw() {
                ctx.clearRect(0, 0, width, height);
                drawGrid();
                
                if (appMode === 'ops') {
                    drawOpsMode();
                } else {
                    drawResMode();
                }
            }
            
            function drawOpsMode() {
                calculateResultant();
                
                // Draw A and B
                drawVector(vecA.x, vecA.y, vecA.color, 'A');
                drawVector(vecB.x, vecB.y, vecB.color, 'B');

                // Draw helper vectors and resultant
                if (opMode === 'add') {
                    drawVectorFrom(vecA.x, vecA.y, vecR.x, vecR.y, vecB.color, [5, 5]);
                    drawVectorFrom(vecB.x, vecB.y, vecR.x, vecR.y, vecA.color, [5, 5]);
                    drawVector(vecR.x, vecR.y, vecR.color, 'R = A + B');
                } else if (opMode === 'sub') {
                    drawVector(vecR.x, vecR.y, vecR.color, 'R = A - B');
                    // Draw -B
                    drawVectorFrom(vecA.x, vecA.y, vecR.x, vecR.y, vecB.color, [5, 5]); // -B from A's tip
                    drawVectorFrom(0, 0, -vecB.x, -vecB.y, vecB.color, [5, 5]); // -B from origin
                    drawVectorFrom(-vecB.x, -vecB.y, vecR.x, vecR.y, vecA.color, [5, 5]); // A from -B's tip
                } else if (opMode === 'subBA') {
                    drawVector(vecR.x, vecR.y, vecR.color, 'R = B - A');
                    // Draw -A
                    drawVectorFrom(vecB.x, vecB.y, vecR.x, vecR.y, vecA.color, [5, 5]); // -A from B's tip
                    drawVectorFrom(0, 0, -vecA.x, -vecA.y, vecA.color, [5, 5]); // -A from origin
                    drawVectorFrom(-vecA.x, -vecA.y, vecR.x, vecR.y, vecB.color, [5, 5]); // B from -A's tip
                }
            }
            
            function drawResMode() {
                calculateResolution();
                
                // Draw Resolving Axis
                const axisLength = (Math.max(width, height) / scale) / 1.5;
                const slopeRad = degToRad(slopeAngle);
                ctx.save();
                ctx.strokeStyle = '#6B7280'; // Gray
                ctx.lineWidth = 1.5;
                ctx.setLineDash([8, 8]);
                ctx.beginPath();
                const startX = origin.x - axisLength * Math.cos(slopeRad);
                const startY = origin.y + axisLength * Math.sin(slopeRad);
                const endX = origin.x + axisLength * Math.cos(slopeRad);
                const endY = origin.y - axisLength * Math.sin(slopeRad);
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
                
                // Draw Perpendicular Axis
                const perpRad = degToRad(slopeAngle + 90);
                ctx.strokeStyle = '#A5B4FC'; // Light Indigo
                ctx.beginPath();
                const pstartX = origin.x - axisLength * Math.cos(perpRad);
                const pstartY = origin.y + axisLength * Math.sin(perpRad);
                const pendX = origin.x + axisLength * Math.cos(perpRad);
                const pendY = origin.y - axisLength * Math.sin(perpRad);
                ctx.moveTo(pstartX, pstartY);
                ctx.lineTo(pendX, pendY);
                ctx.stroke();
                ctx.restore();
                
                // Draw Vectors
                drawVector(vecV.x, vecV.y, vecV.color, 'V');
                drawVector(vecParallel.x, vecParallel.y, vecParallel.color, 'V∥');
                drawVector(vecPerp.x, vecPerp.y, vecPerp.color, 'V⊥');
                
                // Draw construction lines
                drawVectorFrom(vecParallel.x, vecParallel.y, vecV.x, vecV.y, vecPerp.color, [2, 2]);
                drawVectorFrom(vecPerp.x, vecPerp.y, vecV.x, vecV.y, vecParallel.color, [2, 2]);
            }

            // --- Event Listeners ---
            
            // Tab Switching
            function switchTab(mode) {
                appMode = mode;

                // update button styles (no @apply)
                if (mode === 'ops') {
                    tabOps.className = 'py-2 px-4 font-medium text-sm rounded-lg bg-indigo-600 text-white shadow w-1/2';
                    tabRes.className = 'py-2 px-4 font-medium text-sm rounded-lg bg-gray-200 text-gray-700 hover:bg-gray-300 w-1/2';
                    controlsOps.classList.remove('hidden');
                    controlsRes.classList.add('hidden');
                } else {
                    tabRes.className = 'py-2 px-4 font-medium text-sm rounded-lg bg-indigo-600 text-white shadow w-1/2';
                    tabOps.className = 'py-2 px-4 font-medium text-sm rounded-lg bg-gray-200 text-gray-700 hover:bg-gray-300 w-1/2';
                    controlsRes.classList.remove('hidden');
                    controlsOps.classList.add('hidden');
                }
                draw();
            }
            tabOps.addEventListener('click', () => switchTab('ops'));
            tabRes.addEventListener('click', () => switchTab('res'));

            // Ops Listeners
            [magAInput, angleAInput].forEach(el => el.addEventListener('input', () => {
                updateVectorFromPolar(vecA, parseFloat(magAInput.value), parseFloat(angleAInput.value));
                draw();
            }));
            [magBInput, angleBInput].forEach(el => el.addEventListener('input', () => {
                updateVectorFromPolar(vecB, parseFloat(magBInput.value), parseFloat(angleBInput.value));
                draw();
            }));
            scaleInput.addEventListener('input', () => {
                scale = parseFloat(scaleInput.value) || 1;
                draw();
            });
            addButton.addEventListener('click', () => { opMode = 'add'; draw(); });
            subtractButton.addEventListener('click', () => { opMode = 'sub'; draw(); });
            subtractBAButton.addEventListener('click', () => { opMode = 'subBA'; draw(); });

            // Res Listeners
            [magVInput, angleVInput].forEach(el => el.addEventListener('input', () => {
                updateVectorFromPolar(vecV, parseFloat(magVInput.value), parseFloat(angleVInput.value));
                draw();
            }));
            slopeAngleInput.addEventListener('input', () => {
                slopeAngle = parseFloat(slopeAngleInput.value) || 0;
                draw();
            });

            // --- Mouse Dragging ---
            function getMousePos(evt) {
                const rect = canvas.getBoundingClientRect();
                const x = (evt.clientX - rect.left);
                const y = (evt.clientY - rect.top);
                // Convert canvas coords to world coords
                const worldX = (x - origin.x) / scale;
                const worldY = (origin.y - y) / scale;
                return { x, y, worldX, worldY };
            }

            function getClosestVector(mouse) {
                const threshold = 15 / scale; // 15px grab radius
                let closest = null;
                let minDist = threshold;

                if (appMode === 'ops') {
                    const distA = Math.hypot(mouse.worldX - vecA.x, mouse.worldY - vecA.y);
                    const distB = Math.hypot(mouse.worldX - vecB.x, mouse.worldY - vecB.y);
                    const distR = opMode ? Math.hypot(mouse.worldX - vecR.x, mouse.worldY - vecR.y) : Infinity;
                    
                    if (distA < minDist) {
                        closest = 'A';
                        minDist = distA;
                    }
                    if (distB < minDist) {
                        closest = 'B';
                        minDist = distB;
                    }
                    if (distR < minDist) {
                        closest = 'R';
                    }
                } else if (appMode === 'res') {
                    const distV = Math.hypot(mouse.worldX - vecV.x, mouse.worldY - vecV.y);
                    const distPara = Math.hypot(mouse.worldX - vecParallel.x, mouse.worldY - vecParallel.y);
                    const distPerp = Math.hypot(mouse.worldX - vecPerp.x, mouse.worldY - vecPerp.y);
                    
                    if (distV < minDist) {
                        closest = 'V';
                        minDist = distV;
                    }
                    if (distPara < minDist) {
                        closest = 'V_PARALLEL';
                        minDist = distPara;
                    }
                    if (distPerp < minDist) {
                        closest = 'V_PERP';
                    }
                }
                return closest;
            }

            canvas.addEventListener('mousedown', (e) => {
                const mouse = getMousePos(e);
                dragging = getClosestVector(mouse);
                if (dragging) {
                    canvas.style.cursor = 'grabbing';
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                const mouse = getMousePos(e);
                
                if (dragging) {
                    canvas.style.cursor = 'grabbing';
                    if (dragging === 'A') {
                        updateVectorFromCartesian(vecA, mouse.worldX, mouse.worldY);
                        updateOpsInputs();
                    } else if (dragging === 'B') {
                        updateVectorFromCartesian(vecB, mouse.worldX, mouse.worldY);
                        updateOpsInputs();
                    } else if (dragging === 'R') {
                        const dx = mouse.worldX - vecR.x;
                        const dy = mouse.worldY - vecR.y;
                        updateVectorFromCartesian(vecA, vecA.x + dx / 2, vecA.y + dy / 2);
                        updateVectorFromCartesian(vecB, vecB.x + dx / 2, vecB.y + dy / 2);
                        updateOpsInputs();
                    } else if (dragging === 'V') {
                        updateVectorFromCartesian(vecV, mouse.worldX, mouse.worldY);
                        updateResInputs();
                    } else if (dragging === 'V_PARALLEL') {
                        // Project mouse onto parallel axis
                        const slopeRad = degToRad(slopeAngle);
                        const v = { x: mouse.worldX, y: mouse.worldY };
                        const dot = v.x * Math.cos(slopeRad) + v.y * Math.sin(slopeRad);
                        const projX = dot * Math.cos(slopeRad);
                        const projY = dot * Math.sin(slopeRad);
                        updateVectorFromCartesian(vecParallel, projX, projY);
                        
                        // Reconstruct V
                        updateVectorFromCartesian(vecV, vecParallel.x + vecPerp.x, vecParallel.y + vecPerp.y);
                        updateResInputs();

                    } else if (dragging === 'V_PERP') {
                        // Project mouse onto perpendicular axis
                        const perpRad = degToRad(slopeAngle + 90);
                        const v = { x: mouse.worldX, y: mouse.worldY };
                        const dot = v.x * Math.cos(perpRad) + v.y * Math.sin(perpRad);
                        const projX = dot * Math.cos(perpRad);
                        const projY = dot * Math.sin(perpRad);
                        updateVectorFromCartesian(vecPerp, projX, projY);
                        
                        // Reconstruct V
                        updateVectorFromCartesian(vecV, vecParallel.x + vecPerp.x, vecParallel.y + vecPerp.y);
                        updateResInputs();
                    }
                    draw();
                } else {
                    // Check for hover
                    const hoverTarget = getClosestVector(mouse);
                    canvas.style.cursor = hoverTarget ? 'grab' : 'crosshair';
                }
            });

            canvas.addEventListener('mouseup', () => {
                dragging = null;
                canvas.style.cursor = 'crosshair';
            });

            canvas.addEventListener('mouseout', () => {
                dragging = null;
                canvas.style.cursor = 'default';
            });
            
            // --- Initialization ---
            window.addEventListener('resize', resizeCanvas);
            
            // Set initial values from inputs
            updateVectorFromPolar(vecA, parseFloat(magAInput.value), parseFloat(angleAInput.value));
            updateVectorFromPolar(vecB, parseFloat(magBInput.value), parseFloat(angleBInput.value));
            updateVectorFromPolar(vecV, parseFloat(magVInput.value), parseFloat(angleVInput.value));
            slopeAngle = parseFloat(slopeAngleInput.value) || 0;

            resizeCanvas(); // Initial draw
        });
    </script>
</body>
</html>
